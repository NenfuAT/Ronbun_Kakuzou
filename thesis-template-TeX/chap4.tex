\chapter{推定システム}
本章では3章で述べた推定手法を用いて作成したシステムについて述べる．
本システムのシステム構成は次の図\ref{fig:sys}の通りである．
\figimage{images/system.pdf}{150}{システム構成図}{fig:sys}
まずウェアラブルデバイスを用いてセンシングを行いストレージサーバへ保存しておく．
次に可視化システムから推定を行いたいセンサデータを選択し，推定サーバへデータクエリパラメータとして保存先のURLが送られる．
可視化システムから推定サーバへリクエストが来たタイミングでセンサデータから推定を始める．
推定サーバは送られてきたURLからセンサデータを取得し計算を行った後結果を可視化システムへ返却する．
返却された推定結果を元に手首の動きを画面上に再現し特徴量の抽出に役立てる流れである．
各節では本システムを「センサデータ取得アプリ」「推定サーバ」「可視化システム」に分けて説明する．
\section{センサデータ取得アプリ}
スマートウォッチを用いたセンシングには以下の3つの問題がある．
初めにスマートウォッチはスマートフォンと異なりケーブルを用いたデータの送信が不可能である．
スマートフォンはUSBケーブルを用いてPCとのデータ送信が可能だがスマートウォッチにはUSB端子が存在していない．
次に，内部ストレージの容量もスマートフォンより劣っている．
センシングしたデータをスマートウォッチに保持し続けた場合内部ストレージの容量がいずれ足りなくなり新しくデータの取得が不可能となってしまう．
最後に加速度・角速度を同時に保存できるようなアプリはストアに公開されていないという問題がある．
単一のデータを取得するようなアプリは公開されていたが複数のデータを取得するアプリは見つからなかった．
また，存在していたとしても上の2つの問題も解決する必要がある．

以上の問題を解決するために
加速度・角速度センサを同時に取得可能で，データの送信のためサーバとの通信も行えるアプリをKotlinを用いて自作した．
作成したアプリが次の図\ref{fig:sensing}である．
\figimage{images/sensing.pdf}{150}{センシングアプリの各画面}{fig:sensing}
機能としては複数のセンサを選択して同時にセンシングを行う機能とデータをサーバへ送信する機能がある．
WearOSのベースであるAndroidの仕様としてデータ遅延の設定がある．
次の表\ref{table:sensor}に示すように4種類用意されている．
\begin{table}[ht]
    \centering
    \caption{センサのデータ遅延設定}
    \label{table:sensor}
    \resizebox{70mm}{!}{ 
        \begin{tabular}{|c|c|}
            \hline
            設定 & 遅延(μs)  \\
            \hline
            SENSOR\_DELAY\_NORMAL & 200,000  \\
            SENSOR\_DELAY\_GAME & 20,000  \\
            SENSOR\_DELAY\_UI & 60,000  \\
            SENSOR\_DELAY\_FASTEST & 0 \\
            \hline
        \end{tabular}
    }
\end{table}
間隔が速すぎた場合十分な変化量が得られない可能性があるので今回はSENSOR\_DELAY\_NORMALを使用した．
あくまで設定であり使用する機種によって実際の取得頻度が変化するためサンプリングレートは推定サーバの方で適時計算を行い対応する．
データの送信先としてオブジェクトストレージのAmazonS3互換オープンソースであるMiniOを使用したサーバを作成した．
オブジェクトストレージサーバを作成した際に一緒に作成したAPIを使用し，センシングアプリからオブジェクトストレージサーバへデータを表\ref{table:acc}，表\ref{table:gyro}csvファイルとして保存している．
\begin{table}[ht]
    \centering
    \caption{加速度データの形式の例}
    \label{table:acc}
    \resizebox{100mm}{!}{ 
        \begin{tabular}{|cccc|}
            \hline
            time & acc\_x & acc\_y & acc\_z \\
            \hline
            1732681717682 & 0.62462102 & -0.56413518 & 9.750197 \\
            1732681717767 & 0.63001084 & -0.61563796 & 9.757982  \\
            1732681717842 & 0.638993885 & -0.57192048 & 9.757982  \\
            \vdots & \vdots & \vdots & \vdots \\
            \hline
        \end{tabular}
    }
\end{table}
\begin{table}[ht]
    \centering
    \caption{角速度データの形式の例}
    \label{table:gyro}
    \resizebox{100mm}{!}{ 
        \begin{tabular}{|cccc|}
            \hline
            time & gyro\_x & gyro\_y & gyro\_z  \\
            \hline
            1732681717682 & 0.027004715 & -0.00505507 & 0.00718352  \\
            1732681717767 & 0.035518516 & -0.0081147175 & 0.0015963378  \\
            1732681717842 & 0.044032317 & -0.011174365 & -0.0039908444  \\
            \vdots & \vdots & \vdots & \vdots \\
            \hline
        \end{tabular}
    }
\end{table}
データの送信形式にはマルチパートフォームデータを使用した．
一般的なhttp通信によるWebAPIではJSON形式のデータを用いる場合が多い，しかし今回はファイルを送信する必要があるためバイナリを扱えるマルチパートフォームデータの形式を採用した．
それぞれの形式の例を図\ref{fig:data}に示す．
図\ref{fig:data}のようにコンテンツタイプを指定し，csvファイルとして送信が可能となる．
\figimage{images/data.pdf}{150}{データの送信形式}{fig:data}
その際送信に成功したタイミングでスマートウォッチ内のデータは削除するようにして内部ストレージの問題も解決した．

\section{推定サーバ}
3章で述べた推定手法をAPIサーバとして実装したものが推定サーバである．
クォータニオンの計算など複雑な計算を行う必要があるため，計算系のライブラリが充実しているPythonを使用してサーバを作成した．
可視化システムから受け取った署名付きURLを用いてMiniOサーバからセンサデータのcsvファイルを取得している．
取得したデータはタイムスタンプが一致していない場合があるため，線形補間を用いて加速度・角速度のデータ数・タイムスタンプを一致させる．
補完後のデータを用いて3章で述べた推定手法を使用し，推定アルゴリズムを動かしクォータニオンと移動距離の計算を行う．
計算後のクォータニオンと移動距離を表\ref{table:quotanion}，表\ref{table:distance}csv形式として可視化システムへ返却している．
\begin{table}[ht]
    \centering
    \caption{クォータニオンデータの形式の例}
    \label{table:quotanion}
    \resizebox{150mm}{!}{ 
        \begin{tabular}{|ccccc|}
            \hline
            time & w & x & y & z \\
            \hline
            1732681719132 & 0.9978874137967442 & -0.05634797999043905 & -0.03115239363645531 & 0.00866850089473444 \\
            1732681719214 & 0.9980955904502076 & -0.05302987799138242 & -0.030382473160154275 & 0.008362397308374306 \\
            1732681719299 & 0.9981994886509393 & -0.050598461702549426 & -0.031199906376175496 & 0.008008893335342339 \\
            \vdots & \vdots & \vdots & \vdots & \vdots \\
            \hline
        \end{tabular}
    }
\end{table}
\begin{table}[ht]
    \centering
    \caption{移動データの形式の例}
    \label{table:distance}
    \resizebox{150mm}{!}{ 
        \begin{tabular}{|cccc|}
            \hline
            time & dis\_x & dis\_y & dis\_z  \\
            \hline
            1732681719132 & -0.012897410812599637 & 0.008514756891280497 & 0.011569086766364466 \\
            1732681719214 & -0.012740526372956418 & 0.008723961213618795 & 0.010483328539204296 \\
            1732681719299 & -0.012569902674072929 & 0.008939466947283523 & 0.009410297204784182 \\
            \vdots & \vdots & \vdots & \vdots \\
            \hline
        \end{tabular}
    }
\end{table}
その際，マルチパートフォームデータ内に直接書き込みcsvファイルを一度サーバ内に保存する処理を省略している．

\section{可視化システム}
ここまでの手法で求めた回転・移動は3次元の動きのためグラフで可視化が困難であり特徴量の抽出が難しい．
そこで手首の動きを画面上に再現するシステムを作成した．
本システムは誰でも使用できるようNext.jsを用いてWebアプリとして作成を行った．

初期画面(図\ref{fig:kashika1})ではMiniOに保存されているデータの一覧を取得して表示を行なっている．
\figimage{images/kashika1.pdf}{150}{データ選択画面}{fig:kashika1}
推定を行いたい加速度・角速度のセンサデータを選択すると推定サーバへ署名付きURLをクエリパラメータとして送信している．
推定サーバから推定結果を受けとると可視化画面(図\ref{fig:kashika2})へ遷移する．
\figimage{images/kashika2.pdf}{150}{可視化画面}{fig:kashika2}
可視化を行うための3次元空間はThree.jsを使用し描画した3Dモデルを動作させ可視化を行なった．
スマートウォッチの3Dモデルは3DモデリングツールであるBlenderを使用してモデリングを行った(図\ref{fig:blender})．
\figimage{images/blender.pdf}{150}{モデリングの様子}{fig:blender}
Blenderの座標系はz軸が上のZup方式だがThree.jsではy軸が上のYupである．
そのため作成したモデルがそのまま描画すると90度傾いてしまうため変換を行なってから描画している．

